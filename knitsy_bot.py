# -*- coding: utf-8 -*-
"""Knitsy Bot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wkadp_2X8DoHwZELFnB1Hp6yOMrgYGgd
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Part 0: Strategy, Tests, and Cleaning

### Strategy and Useful Scripts

![image.png](data:image/png;base64,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)
"""

#DO NOT RUN THIS CELL

# messages folder location: /content/drive/MyDrive/Colab Notebooks/messages

##################################
# Conversion of JSON data to the dictionary above
  
import json
  
with open('data.json') as json_file:
    data = json.load(json_file)
  
    # Print the type of data variable
    print("Type:", type(data))
  
    # Print the data of dictionary
    print("\nPeople1:", data['people1'])
    print("\nPeople2:", data['people2'])

##################################

#Creating dataframe from dictionary object.
import pandas as pd
data = [{'name': 'vikash', 'age': 27}, {'name': 'Satyam', 'age': 14}]
df = pd.DataFrame.from_dict(data, orient='columns')

#CELL RUNS BUT IS NOT USEFUL
#Printed count tells me how many conversations (folders) there are

import os

# abspath to a folder as a string
folder = '/content/drive/MyDrive/Colab Notebooks/messages'


count = 0

for dirname, dirs, files in os.walk(folder):
    for filename in files:
        filename_without_extension, extension = os.path.splitext(filename)
        if extension == '.json':
            count +=1
            #print(filename_without_extension)
print(count, lines)

"""### Test Run"""

import json
import os

folder = '/content/drive/MyDrive/Colab Notebooks/messages'


count = 0

for dirname, dirs, files in os.walk(folder):
    for filename in files:
      filename_without_extension, extension = os.path.splitext(filename)
      if extension == '.json':
        count += 1
        #print(dirname,count)
        with open(dirname+'/'+filename) as json_file:
          data = json.load(json_file)
          data['messages']['message_id'] = count
      if count>24:
        break
    if count>24:
      break

len(data['messages'])

import pandas as pd

df = pd.DataFrame()
for message in data['messages']:
  m = pd.DataFrame.from_dict(message, orient='index')
  m = m.T
  #print(m)
  df = df.append(m)

print(df.sample())

# Test run with assigning conversation and message ID numbers

conversation_count = 0

df = pd.DataFrame()

for dirname, dirs, files in tqdm(os.walk(folder)):
    for filename in files:
      filename_without_extension, extension = os.path.splitext(filename)
      if extension == '.json':
        with open(dirname+'/'+filename) as json_file:
          conversation_count += 1
          data = json.load(json_file)
          message_count = 0
          for message in data['messages']:
            message_count += 1
            m = pd.DataFrame.from_dict(message, orient='index')
            m = m.T
            m['conversation_id'] = conversation_count
            m['message_id'] = message_count
            df = df.append(m)
      if conversation_count > 5:
        break
    if conversation_count>5:
      break

df.head()

"""### Combine all messages into one dataframe


"""

#This is now deprecated.
#1847 Items
#Run-time between 10 and 18 minutes

from tqdm import tqdm
import pandas as pd
import os
import json

folder = '/content/drive/MyDrive/Colab Notebooks/messages'

df = pd.DataFrame()

for dirname, dirs, files in tqdm(os.walk(folder)):
    for filename in files:
      filename_without_extension, extension = os.path.splitext(filename)
      if extension == '.json':
        with open(dirname+'/'+filename) as json_file:
          data = json.load(json_file)
          for message in data['messages']:
            m = pd.DataFrame.from_dict(message, orient='index')
            m = m.T
            df = df.append(m)

len(df)

df.tail(10)

"""### Clean the Data"""

from datetime import datetime

#timestamp = 1582640934834
#dt_object = datetime.fromtimestamp(timestamp)

df['timestamp_ms'] = df['timestamp_ms'].apply(lambda x : datetime.fromtimestamp(int(x)/1000))

df.sample()

#Encrypt the names of customers. An important ethical step to safeguard the identity of our customers

def encrypt(text,s):
  result = ""
    # transverse the plain text
  for i in range(len(text)):
    char = text[i]
    # Encrypt uppercase characters in plain text
    
    if (char.isupper()):
      result += chr((ord(char) + s-65) % 26 + 65)
    # Encrypt lowercase characters in plain text
    else:
      result += chr((ord(char) + s - 97) % 26 + 97)
  return result

#check the above function
text = "CEASER CIPHER DEMO"
s = 4

e= encrypt(text,s)

print(e)

df['sender_name'] = df['sender_name'].apply(lambda x : encrypt(x,16) if x != "Logo Knits" else "Logo Knits")

df.sample()

df = df.fillna("empty")

df.sample()

"""# Part 1: EDA

### Size of dataset and counts of empty values
"""

print(f"There are {len(df)} messages from 1428 conversations ")
no_content = df[df.content==0]
print(f"There are {len(no_content)} that do not have message content. Of these, there are {(no_content.photos == 0).sum()} messages that do not have photo attachments.")

"""### Source and Target

The source and target are in the same column as it stands (df.content). So it will obviously be important for me to come up with a way to identify how the messages are relating to each other. I think that the best way will be to make some sort of conversation_id. It won't make sense to use the timestamp, because many times there are several conversations going on at once, so the timestamps will overlap. The conversations are organized in folders. So think the a good way will be to create an index for each folder that I can tie the conversation to. Possibly I can group by this index so that it's a more clear distinction.

Right now, the conversations are in order. So even if the timestamps are overlapping, if I iterate down the rows, the conversations will make sense. This is because the dataframe was built by looping through the folder structure containing the .json files.

I suppose it's possible to leave it like this, but the obvious draw back is that there is no way to seperate when a conversation ends and when a new one begins. They all flow into eachother. There will 1400+ points such as this in the dataset and this is obviously too many. I think it will give a bad result.

I should think carefully about this step, but I think the method I mentioned above is the best solution. An id number for each conversation/folder.

# Part 2: Preprocessing

## Test Dataset

### Tokenization
"""

df_test = df.sample(500)

import nltk
nltk.download('punkt')

def to_lower(text):
  str(text)
  return text.lower()

df_test['content']=df_test['content'].apply(to_lower)

from nltk.corpus import stopwords
nltk.download('stopwords')

stop = stopwords.words('english')

def custom_stopwords(text):
    if not text:
        #print('The text to have stop words removed is a None type or integer. Defaulting to blank string.')
        text = ''
    return ' '.join([word for word in text.split() if word not in (stop)])

df_test['no_stopwords'] = df_test['content'].apply(custom_stopwords)

df_test.sample()

def custom_tokenize(text):
    if not text:
        #print('The text to be tokenized is a None type or integer. Defaulting to blank string.')
        text = ''
    return nltk.word_tokenize(text)

df_test['tokenized_no_stopwords'] = df_test.no_stopwords.apply(custom_tokenize)

def custom_tokenize(text):
    if not text:
        #print('The text to be tokenized is a None type or integer. Defaulting to blank string.')
        text = ''
    return nltk.word_tokenize(text)

df_test['tokenized_raw'] = df_test.content.apply(custom_tokenize)

df_test.sample()

from collections import Counter
from  itertools import chain
import pandas as pd

top_20 = pd.Series(Counter(chain(*df_test.tokenized_no_stopwords)))

import string

top_20 = top_20.sort_values(ascending=False)

#Puncation not stripped during stop word filtering. Doing this now only for the purpose of showing the most common words.
# top_20 df is not to be used elsewhere

top_20 = top_20.drop(labels=['$', '!', '.', '?'])
top_20 = top_20.drop(labels=['\'s'])
top_20 = top_20.drop(labels=['\'\''])
top_20 = top_20.drop(labels=[','])

top_20.head(20)

"""These words are the result that I expected to find. The company is a blanket manufacturer and retailer. So it's expected to find that blanket/s occupy the tp two positions. The rest of the words are generally from customers inquiring about pricing, minimums, or other basic questions.

### Statistical Analysis
(length of word, length of sentence,  lexical diversity)
"""

corpus = sum(df_test['tokenized_no_stopwords'], [])

raw_corpus = ' '.join(df_test['content'])

from nltk import FreqDist

fd = FreqDist(corpus)
fd.plot(50, cumulative=True, title="50 most common tokens in Custom Service Corpus")

fd_nopunc = FreqDist(dict((word, freq) for word, freq in fd.items() if word.isalpha()))
fd_nopunc.plot(50, cumulative=True, title="50 most common tokens in Custom Service Corpus, Punctuation Omitted")

from nltk import Text

corpus_text = Text(corpus)
corpus_text.dispersion_plot(['blanket', 'price', 'size', 'order'])

print(fd.hapaxes()[:25])

print(corpus_text.collocations())

sent_text = nltk.sent_tokenize(raw_corpus)
word_text = nltk.word_tokenize(raw_corpus)

import math

lengths = [len(i) for i in sent_text]
average_sentence_length = sum(lengths)/len(lengths)

average_sentence_length

"""The above I think is not correct because I am working with messages in the column of a dataframe rather than a text document. I converted these messages to a corpus in order to run these experiments, but I think the results are not useful."""

import numpy as np

average_word_length = df_test['tokenized_no_stopwords'].apply(lambda x: np.mean([len(y) for y in x]))

print(f"The average word length in a message (tokenized with stop words removed) is {np.round(np.mean(average_word_length),2)}")

average_message_length = df_test['tokenized_no_stopwords'].apply(lambda x: np.mean([len(x)]))
print(f"The average word length in a message (tokenized with stop words removed) is {np.round(np.mean(average_message_length),2)}")

"""These results make more sense and then average sentence length of 4 coincides with what was found in the Week 3 NLTK workshop

### Stemmer, Lemmatizer, POS tagger, NER

         

Make sure to have separate layers for each task (= separate vector/arrays), do not process them in a linear sequence. Do not apply pos tagger and NER to lemmatizer and stemmer output and do not apply lemmatizer to stemmer output (a customized function will help you control which option to choose) - see Lecture 3 about processing pipeline.

Note - for POS tagger you need a tokenized raw corpus  (keep punctuation, stopwords, capitalization), for stemmer and lemmatizer, you should use a tokenized corpus without punctuation, stopwords, upper cases. For NER you can use spaCy method (see example):

#### Porter Stemmer
"""

df_smalltest = df_test.sample(10)

from nltk.stem import PorterStemmer

ps=PorterStemmer()
df_smalltest['stems'] = df_smalltest['tokenized_no_stopwords'].apply(lambda x: [ps.stem(word) for word in x])

df_smalltest['stems'].sample().all()

"""#### Lemmatizer"""

from nltk.stem import WordNetLemmatizer
lemmatizer = WordNetLemmatizer()

df_smalltest['lemmatized'] = df_smalltest['tokenized_no_stopwords'].apply(lambda x: [ps.stem(word) for word in x if word.isalpha()])

df_smalltest['lemmatized'].sample().all()

"""#### POS Tagger"""

nltk.download('averaged_perceptron_tagger')

df_smalltest['POS tagged'] = df_smalltest['tokenized_raw'].apply(lambda x: nltk.pos_tag(x))

df_smalltest['POS tagged'].sample().all()

"""Example from instructions:

```
import spacy
from spacy import displacy
from collections import Counter
import en_core_web_sm
nlp = en_core_web_sm.load()
doc = nlp('European authorities fined Google a record $5.1 billion on Wednesday for abusing its power in the mobile phone market and ordered the company to alter its practices')
print([(X.text, X.label_) for X in doc.ents])
```




"""

import spacy
from spacy import displacy
from collections import Counter
import en_core_web_sm
nlp = en_core_web_sm.load()
#doc = nlp('European authorities fined Google a record $5.1 billion on Wednesday for abusing its power in the mobile phone market and ordered the company to alter its practices')
df_smalltest['NER doc'] = df_smalltest['content'].apply(lambda x: nlp(x))
df_smalltest['NER'] = df_smalltest['NER doc'].apply(lambda x: [(y.text, y.label_) for y in x.ents])
#print([(X.text, X.label_) for X in doc.ents])

df_smalltest['NER'].sample().all()

"""## Entire Dataset

### Preprocesser Class and Methods
"""

import nltk
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
import spacy
from spacy import displacy
from collections import Counter
import en_core_web_sm
from nltk.stem import PorterStemmer
from datetime import datetime
import re

nltk.download('punkt')
nltk.download('stopwords')
nltk.download('averaged_perceptron_tagger')


#Function definitions required for the Preprocesser Class

def encrypt(text,s):
  result = ""
    # transverse the plain text
  for i in range(len(text)):
    char = text[i]
    # Encrypt uppercase characters in plain text
    
    if (char.isupper()):
      result += chr((ord(char) + s-65) % 26 + 65)
    # Encrypt lowercase characters in plain text
    else:
      result += chr((ord(char) + s - 97) % 26 + 97)
  return result

def strip_and_lower(text):
  str(text)
  text = re.sub(r'[^a-zA-Z\s]', '', text, re.I|re.A)
  text = text.lower()
  text = text.strip()
  return text

def custom_stopwords(text):
    if not text:
        #print('The text to have stop words removed is a None type or integer. Defaulting to blank string.')
        text = ''
    return ' '.join([word for word in text.split() if word not in (stop)])

def custom_tokenize(text):
    if not text:
        #print('The text to be tokenized is a None type or integer. Defaulting to blank string.')
        text = ''
    return nltk.word_tokenize(text)

#Intialize required objects for the Preprocessor Class
ps=PorterStemmer()
nlp = en_core_web_sm.load()
stop = stopwords.words('english')
lemmatizer = WordNetLemmatizer()



class Preprocesser:

  def __init__(self, df):
    self.df = df

  def clean(self):
    #self.df['timestamp_ms'] = self.df['timestamp_ms'].apply(lambda x : datetime.fromtimestamp(int(str(x))/1000))
    self.df['sender_name'] = self.df['sender_name'].apply(lambda x : encrypt(x,16) if x != "Logo Knits" else "Logo Knits")
    self.df = self.df.fillna("empty")

  
  def process(self):
    self.df['content_raw'] = self.df['content']
    self.df['content']=self.df['content'].apply(strip_and_lower)
    self.df['no_stopwords'] = self.df['content'].apply(custom_stopwords)
    self.df['tokenized_no_stopwords'] = self.df['no_stopwords'].apply(custom_tokenize)
    self.df['tokenized_raw'] = self.df['content_raw'].apply(custom_tokenize)
    self.df['stems'] = self.df['tokenized_no_stopwords'].apply(lambda x: [ps.stem(word) for word in x])
    self.df['lemmatized'] = self.df['tokenized_no_stopwords'].apply(lambda x: [ps.stem(word) for word in x if word.isalpha()])
    self.df['POS tagged'] = self.df['tokenized_raw'].apply(lambda x: nltk.pos_tag(x))
    self.df['NER doc'] = self.df['content'].apply(lambda x: nlp(x))
    self.df['NER'] = self.df['NER doc'].apply(lambda x: [(y.text, y.label_) for y in x.ents])

  def show_samples(self):
    print("Content sample:")
    print(self.df['content'].sample().all())
    print("")
    print("No Stopwords sample:")
    print(self.df['no_stopwords'].sample().all())
    print("")
    print("Tokenized No Stopwords sample:")
    print(self.df['tokenized_no_stopwords'].sample().all())
    print("")
    print("Tokenized Raw sample:")
    print(self.df['tokenized_raw'].sample().all())
    print("")
    print("Stems sample:")
    print(self.df['stems'].sample().all())
    print("")
    print("Lemmatized sample:")
    print(self.df['lemmatized'].sample().all())
    print("")
    print("POS Tagged sample:")
    print(self.df['POS tagged'].sample().all())
    print("")
    print("NER Doc sample:")
    print(self.df['NER doc'].sample().all())
    print("")
    print("NER sample:")
    print(self.df['NER'].sample().all())
    print("")

"""### Load messages and assign message_id"""

from tqdm import tqdm
import pandas as pd
import os
import json

conversation_count = 0

df = pd.DataFrame()

#1847 Items
#Run-time usually between 10 and 18 minutes

folder = '/content/drive/MyDrive/Colab Notebooks/messages'

for dirname, dirs, files in tqdm(os.walk(folder)):
    for filename in files:
      filename_without_extension, extension = os.path.splitext(filename)
      if extension == '.json':
        with open(dirname+'/'+filename) as json_file:
          conversation_count += 1
          data = json.load(json_file)
          message_count = 0
          for message in data['messages']:
            message_count += 1
            m = pd.DataFrame.from_dict(message, orient='index')
            m = m.T
            m['conversation_id'] = conversation_count
            m['message_id'] = message_count
            df = df.append(m)

#checksum conversation_count
conversation_count == 1428

preprocessor = Preprocesser(df)
preprocessor.clean()
preprocessor.process()

preprocessor.show_samples()

"""I think that the results here are quite good. I don't expect to find many samples that have more than one or two results in the NER list. The conversations are usually quite casual and I think that if there is a Named Entity, it will most likely be a shipping address or a quantity.

# Part 3

### CountVectorizer

apply CountVectorizer from sklearn 

what is your vocabulary size (shape of your matrix)?
sort and print top 10 frequent words
"""

from sklearn.feature_extraction.text import CountVectorizer
import re
import numpy as np


corpus = sum(preprocessor.df['tokenized_no_stopwords'], [])

# get bag of words features in sparse format
cv = CountVectorizer(min_df=0., max_df=1.)
cv_matrix = cv.fit_transform(corpus)
cv_matrix

cv_matrix.shape

counts = pd.DataFrame(cv_matrix.toarray(),
                      columns=cv.get_feature_names())
counts

counts['blanket'].sum()

s = counts.sum()

s.nlargest(n=10)

"""### TfidfTransformer and Vectorizer

what is your vocabulary size (shape of your matrix)?

sort and print top 10 frequent words

"""

from sklearn.feature_extraction.text import TfidfVectorizer

tv = TfidfVectorizer(min_df=0., max_df=1., norm='l2',
                     use_idf=True, smooth_idf=True)
tv_matrix = tv.fit_transform(corpus)
tv_matrix = tv_matrix.toarray()

vocab = tv.get_feature_names()
tfidf = pd.DataFrame(np.round(tv_matrix, 2), columns=vocab)

tfidf.sample(10)

tfidf.shape

tfidf['blankets'].sample(10)

t_s = tfidf.sum()
t_s.nlargest(n=10)

"""I'm confused by this result. My tfidf dataframe is looks identical to the CountVectorizer dataframe except the numbers are floats instead of integers. I don't think that there are any fractions. ***I tried using both tfidfTransformer and tfidfVectorizer, and the results were the same.***
Is it possibly because there is so little variation in the topics being discussed?
The code I used is directly from Ch04a Feature Engineering notebook.
"""

from sklearn.feature_extraction.text import TfidfTransformer

tt = TfidfTransformer(norm='l2', use_idf=True, smooth_idf=True)
tt_matrix = tt.fit_transform(cv_matrix.toarray())

tt_matrix = tt_matrix.toarray()
vocab = cv.get_feature_names()
tfidf = pd.DataFrame(np.round(tt_matrix, 2), columns=vocab)

t_s = tfidf.sum()
t_s.nlargest(n=10)

!cp drive/My Drive/Colab Notebooks/Knitsy Bot.ipynb ./
!jupyter nbconvert --to PDF "Knitsy Bot.ipynb"

